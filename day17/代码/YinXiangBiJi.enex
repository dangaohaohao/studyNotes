<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export2.dtd">
<en-export export-date="20190826T151128Z" application="Evernote/Windows" version="6.x">
<note><title>day17</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note><div><span style="font-size: 16pt; color: rgb(227, 0, 0); font-weight: bold;">ES6常用API</span></div><div><br/></div><div><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">let与const</span></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">let关键字，用来声明变量，它的用法类似于var。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">let不允许重复声明变量；</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var a = 1;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var a = 2;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(a);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let b = 1;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let b = 2;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(b);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">let声明变量仅在块级作用域内有效；</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (var i = 0; i &lt; 10; i++) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;console.log(i);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert(i);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (let v = 0; v &lt; 10; v++) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(v);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert(v);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">不能通过let声明和形参相同的变量；</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function test(a) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;let a = 123;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(a);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">test(456);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">let声明变量不会提升；</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert(a);&nbsp;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var a = 2;</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert(b);&nbsp;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let b = 2;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">注意：let声明的变量一定要在声明之后使用，否则报错。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">暂时性死区;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">ES6规定在某个区块中， 一旦用let或const声明一个变量，那么这个区块就变成块级作用域，用let或const声明的变量就“绑定”这个区域，不再受外部的影响。 在该变量声明之前不可以用，在语法上我们叫这种情况为：暂时性死区 (temporal dead</span> <font face="微软雅黑" style="font-size: 14pt;">zone，简称 TDZ)。</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">let v = 1;</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">if (true) {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;console.log(v);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;let v = 2;</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log(v);</font></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">上面代码中，存在全局变量v，但是块级作用域内let又声明了一个局部变量v，导致后者绑定这个块级作用域，所以在let声明变量之前，对v赋值会报错。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">let应用：改造选项卡效果</span></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">const关键字，用来声明一个只读的常量。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">const与let类似，</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">但是，const常量一旦声明，常量将不能重新赋值！</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">const AGE = 18;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert(AGE);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">AGE = 20;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert(AGE);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">意味着，const一旦声明，就必须立即初始化，不能留到以后赋值！</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">const AGE;</span></div><div><br/></div><div><br/></div><div><font color="#E30000"><span style="font-size: 14pt; font-family: 微软雅黑;">本质：</span><span style="font-size: 14pt; font-family: 微软雅黑;">const实际上保证的，并不是值不能改变，而是指向的那个内存地址不能改变。</span></font></div><div><font color="#E30000"><span style="font-size: 14pt; font-family: 微软雅黑;"><br/></span></font></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">const FOO = {name: &apos;xm&apos;};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">FOO.age = 18;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(FOO.age);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">FOO = {name: &apos;xh&apos;};</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">注意：为了和变量区分，一般常量用大写字母。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">如：</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">const PI = 3.14;</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">arrow functions(箭头函数)</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">定义：( 形参 ) =&gt; { 函数体 }</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var box = document.getElementById(&apos;box&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">box.onclick = function () {</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// ES5</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(this);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">box.onclick = () =&gt; {</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// ES6</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(this);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">用箭头函数来写比原来的function写法要简洁很多（针对匿名函数使用）。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var reflect = function (value){</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//ES5</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;return value;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let reflect = value =&gt; value;</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//ES6</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">箭头函数与传统的JavaScript函数主要区别在于以下几点：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">1.对 this 的关联。函数内部的 this 指向，取决于箭头函数在哪定义，而非箭头函数的调用对象。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var name = &apos;xh&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;name: &apos;xm&apos;,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;say: () =&gt; {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;alert(this.name);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">obj.say();</span></div><div><br/></div><div><span style="font-family: 微软雅黑; font-size: 14pt;">当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，<font color="#E30000">实际原因是箭头函数根本没有自己的this，它的this是继承外面</font></span><span style="font-family: 微软雅黑; font-size: 14pt;"><font color="#E30000">的，因此内部的this就是外层代码块的this。</font></span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var box = document.getElementById(&apos;box&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">box.onclick = function () {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;setTimeout(() =&gt; {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;console.log(this);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;},2000);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">2.new 不可用。箭头函数不能使用 new 关键字来实例化对象，不然会报错。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var Test = function () {};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = new Test();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var Test = () =&gt; {};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = new Test();</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//Test is not a constructor</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">3.this 不可变。函数内部 this 不可变，在函数体内整个执行环境中为常量。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj1 = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;name: &apos;隔壁王叔叔&apos;,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;age: 33</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">setTimeout(() =&gt; {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;console.log(this);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}.bind(obj1),1000);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//报错</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">4.没有arguments对象。更不能通过arguments对象访问传入参数。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function fn(){</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(arguments[0]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(arguments[1]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">fn(1,2);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var fn = () =&gt; {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(arguments[0]);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//报错</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">fn(3);</span></div></div><div><span style="font-size: 14pt;">&nbsp;</span></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt; font-weight: bold;">template string(（字符串模板）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">ES6中字符串模板使用反引号 ` ` 表示，字符串模板中可以解析变量和函数，使用 ${ } 解析</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var sname = &quot;小错&quot;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function fnAge(){</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;return 18;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var str = `大家好，我叫${sname},我今年${fnAge()}岁了`;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">alert( str );</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">字符串模板非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var box = document.getElementById(&apos;box&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var val1 = 11, val2 = 22, val3 = 33;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">box.innerHTML = &apos;&lt;ul&gt;&lt;li&gt;&apos;+val1+&apos;&lt;/li&gt;&lt;li&gt;&apos;+val2+&apos;&lt;/li&gt;&lt;li&gt;&apos;+val3+&apos;&lt;/li&gt;&lt;/ul&gt;&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">box.innerHTML = &apos;&lt;ul&gt;&apos;+</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&apos;&lt;li&gt;&apos;+val1+&apos;&lt;/li&gt;&apos;+</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&apos;&lt;li&gt;&apos;+val2+&apos;&lt;/li&gt;&apos;+</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&apos;&lt;li&gt;&apos;+val3+&apos;&lt;/li&gt;&apos;+</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&apos;&lt;/ul&gt;&apos;;</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">使用ES6字符串模板：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">box.innerHTML = `</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&lt;ul&gt;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;li&gt;${val1}&lt;/li&gt;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;li&gt;${val2}&lt;/li&gt;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;li&gt;${val3}&lt;/li&gt;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;&lt;/ul&gt;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">`;</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">Destructuring（解构赋值）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">解构赋值：解析结构进行赋值。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var x = 10 , y = 20 , z = 30;</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var cat = &apos;ken&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var dog = &apos;lili&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var zoo = {cat: cat, dog: dog};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(zoo);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">用ES6完全可以像下面这么写：</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var [x,y,z] = [10,20,30];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var {sname,age} = {age : 10, sname : &quot;xm&quot; }</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( sname );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( age );</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let cat = &apos;ken&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let dog = &apos;lili&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let zoo = {cat, dog};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(zoo);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">反过来可以这么写：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let dog = {type: &apos;animal&apos;, many: 2};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let { type, many} = dog;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(type);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(many);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">解构赋值可以作用在函数的参数上，让函数参数的值传递顺序改变</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function fn( {sname,age} ){</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">return `大家好我叫${sname}，我今年${age}岁了`;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( fn( {age:23,sname:&quot;jack&quot;} ) );</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">Array.from( )</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">Array.from：将含有length属性的对象、类数组转成真正的数组。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">Array.from(obj, map函数);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">第一个参数为要转换的对象，第二个参数为一个函数，可选，类似map函数。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">map函数 : 遍历数组--操作数组--返回数组</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr = [1,2,3,4,5];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var newArr = arr.map( (item) =&gt; { return item*2 } );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( newArr );</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">类数组元素集合：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var lis = document.getElementsByTagName(&quot;li&quot;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(lis);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">lis.push(&apos;abc&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(lis);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">将lis集合（类数组）转成 数组：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">lis = Array.from(lis);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( lis )</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">lis.push(&apos;abc&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(lis);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">将对象转成 数组：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;&quot;0&quot; : 10 ,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;&quot;1&quot; : 20 ,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;&quot;2&quot; : 30 ,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;&quot;length&quot; : 3</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr = Array.from( obj );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( arr );</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">第二个参数是一个匿名函数 实现的是map功能：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var newArr = Array.from( obj , (item) =&gt; { return item*2; } )</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( newArr );</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">三个点（...）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">扩展运算符</span><span style="font-size: 14pt; font-family: 微软雅黑;">用三个点号表示，其功能是把数组或类数组对象展开成一系列用逗号隔开的参数序列。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(...[1, 2, 3]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(1, ...[2, 3, 4], 5);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var lis = document.getElementsByTagName(&quot;li&quot;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log([...lis]);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">其他用法：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr1 = [1,2];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr2 = [3,4,5];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function addItems(arr, ...items) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;arr.push(...items);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">addItems(arr1,...arr2);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(arr1);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">arr.push(...items) 和 addItems(arr1,...arr2) 函数调用都使用了扩展运算符将数组变为参数序列</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">注意这行：function addItems(arr, ...items) 这里的三个点并不是扩展运算符，而是 rest运算符</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">rest运算符</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">也</span><span style="font-size: 14pt; font-family: 微软雅黑;">是三个点，其功能与扩展运算符恰好相反，把逗号隔开的参数序列组合成一个数组</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr = [1,2,3];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">function fn(...args) {</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// rest运算符 组合数组</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(args);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">fn(...arr);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 扩展运算符 展开数组</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(...arr);</span></div><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">Set 和 Map</span></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">ES6 提供了两种新的数据结构 Set 和 Map。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Set</span> <span style="font-size: 14pt; font-family: 微软雅黑;">是一个构造函数，用来生成 Set 数据结构，它类似于数组，但是成员的值都是唯一的、没有重复的， 初始化 Set 可以接受一个数组或类数组对象作为参数，也可以创建一个空的 Set：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var s1 = new Set();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var s2 = new Set([1, 2, 3]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(s1);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(s2);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">在 Set 中成员的值是唯一的，重复的值自动被过滤掉</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var s1 = new Set([1, 2, 2, 3, 1, 4]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(s1);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">Set 的一些属性方法：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">size：返回成员总数</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">add(value)：添加某个值，返回Set结构本身</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">has(value)：返回一个布尔值，表示该值是否为Set的成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">clear()：清除所有成员，没有返回值</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var set = new Set([1,2]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">set.add(3);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 添加成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set.size);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 3 成员总数</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// Set(3) {1, 2, 3}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">set.add([4,5]);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 添加成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set.size);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 4 成员总数</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set.has(2));</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// true 有该成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// Set(4) {1, 2, 3, [4, 5]}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">set.delete(2);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 删除成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// Set(3) {1, 3, [4, 5]}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set.has(2));</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// false 没有该成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">set.clear();</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 清除所有成员</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// Set(0) {}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">得益于数据结构 Set 查找更快速高效，但也因为数据结构的内部数据是无序的，无法实现按下标改查，排序等操作</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr = [1,2,3,&apos;a&apos;,4,&apos;b&apos;];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var set = new Set(arr);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set[0]);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// undefined</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(set[&apos;a&apos;]);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// undefined</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">遍历 Set 对象</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var set = new Set([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">set.forEach((val,key,set)=&gt;{</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(&apos;val: &apos;+val);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(&apos;key: &apos;+key);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(set);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">});</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">使用ES6的 for of 遍历（数组，类数组）</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var set = new Set([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (const val of set) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(val);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">Set 没有类似 getter 的方法，怎么取值呢？</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">可以用上面的遍历取值，或者可以把 Set 转成真正的数组！</span></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(255, 0, 0);">for/of 与 for/in</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">for/of：遍历值</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr = [4,5,6,7];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (var val of arr) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(val);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//4 5 6 7</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">for/in：遍历键</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var arr = [4,5,6,7];</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (var key in arr) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(key);</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//0 1 2 3</span></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">var str = &apos;javascript&apos;;</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">for (var val of str) {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;console.log(val);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Map</span> <span style="font-size: 14pt; font-family: 微软雅黑;">是一个构造函数，用来生成 Map 数据结构，它类似于对象，也是键值对的集合，但是“键”可以是非字符串， 初始化 Map 需要一个二维数组，或者直接初始化一个空的 Map：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var m1 = new Map();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var m2 = new Map([[&apos;a&apos;, 123], [&apos;b&apos;, 456], [3, &apos;abc&apos;]]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(m1);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(m2);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">Map 的一些操作方法：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">set(key, value)：设置键值对</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">get(key)：获取键对应的值</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">has(key)：是否存在某个键</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">delete(key)：删除某个键值对，返回一个布尔值，表示删除是否成功</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var map = new Map([[&apos;a&apos;, 123], [&apos;b&apos;, 456], [3, &apos;abc&apos;]]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">map.set(&apos;c&apos;,789);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(map.get(&apos;c&apos;));</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 789</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(map.has(&apos;b&apos;));</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// true 此key存在</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">map.delete(3);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// true 成功删除key</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(map);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// Map(3) {&quot;a&quot; =&gt; 123, &quot;b&quot; =&gt; 456, &quot;c&quot; =&gt; 789}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">遍历 Map 对象</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var map = new Map([[&apos;a&apos;, 123], [&apos;b&apos;, 456], [3, &apos;abc&apos;],[&apos;c&apos;, 789]]);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">map.forEach((val,key,obj)=&gt;{</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(&apos;val: &apos;+val);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(&apos;key: &apos;+key);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(obj);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">});</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">当然也可以使用ES6的 for of 遍历</span></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">var map = new Map([[&apos;a&apos;, 123], [&apos;b&apos;, 456], [3, &apos;abc&apos;],[&apos;c&apos;, 789]]);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">for (const item of map) {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;console.log( item );</font><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">//数组</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for (const [key,val] of map) {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;console.log(key+&apos; : &apos;+val);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">传统 Object 用字符串作键，Object 结构提供了“字符串 — 值”的对应</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">Map 结构提供了“值 — 值”的对应，是一种更完善的 Hash 结构实现</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">如果你需要“键值对”的数据结构，Map 比 Object 更快速 更高效 更合适。</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">Symbol类型</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">ES5 的对象属性名都是字符串，这容易造成属性名的冲突。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(227, 0, 0);">Symbol 是 JavaScript 语言的第七种数据类型。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">在创建symbol类型数据时的参数只是作为标识使用，直接使用 Symbol() 也是可以的。</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let s = Symbol(&apos;xm&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( s );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( typeof s</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">);</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var xm = Symbol();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;[xm] : &quot;小明&quot;</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//对象的属性是Symbol类型</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">Symbol类型的属性 取值是 必须 obj[xm] 不能用obj.xm</span></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log( obj[xm] );</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">var s4 = Symbol();</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">var obj = {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><span>&nbsp;&nbsp; &nbsp;</span>&apos;name&apos;: &apos;xm&apos;,</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><span>&nbsp;&nbsp; &nbsp;</span>[s4]: &apos;xh&apos;,</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><span>&nbsp;&nbsp; &nbsp;</span>[Symbol(&apos;age&apos;)]: 18</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log(obj);&nbsp;</font><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// {name: &quot;xm&quot;, Symbol(): &quot;xh&quot;, Symbol(age): 18}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log(obj.name);</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// xm</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log(obj[s4]);</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// xh 访问对象的Symbol属性的值</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log(obj[Symbol(&apos;age&apos;)]);&nbsp;</font><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// undefined</font></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);"><br/></span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(0, 0, 0);">修改symbol类型的属性</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">obj[xm] = &quot;web前端&quot;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( obj[xm] );</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">对象的Symbol属性不会被遍历出来（可以用来保护对象的某个属性）</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var obj = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;&quot;sname&quot;:&quot;小明&quot;,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;&quot;skill&quot; : &quot;web&quot;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">var age = Symbol();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">obj[age] = 18;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( obj );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">for( var key in obj ){</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;console.log(key + &quot; -&gt; &quot; + obj[key] );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">Object.getOwnPropertySymbols 方法会返回当前对象的所有 Symbol 属性，返回数组</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let id = Symbol(&quot;id&quot;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let obj = {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);"><span>&nbsp;&nbsp; &nbsp;</span>[id]: &apos;007&apos;,</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);"><span>&nbsp; &nbsp; [Symbol(name)]: &apos;xiaocuo&apos;</span><br/></span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let arr = Object.getOwnPropertySymbols(obj);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(arr);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//[S</span><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">ymbol(id),Symbol(name)]</font></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(obj[arr[0]]);&nbsp;&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//&apos;007&apos;&nbsp; 访问对象的Symbol属性的值</span></div><div><br/></div><div><br/></div><div><font face="微软雅黑" style="font-size: 14pt;">虽然这样保证了Symbol的唯一性，但我们不排除希望能够多次使用同一个symbol值的情况。</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">let s1 = Symbol(&apos;name&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">let s2 = Symbol(&apos;name&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log( s1 === s2 );&nbsp;</font><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// false</font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">官方提供了全局注册并登记的方法：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let name1 = Symbol.for(&apos;name&apos;);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//检测到未创建后新建&nbsp;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let name2 = Symbol.for(&apos;name&apos;);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">//检测到已创建后返回&nbsp;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(name1 === name2);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// true</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);"><br/></span></div><div><span style="font-size: 14pt; font-family: 微软雅黑;">通过symbol对象获取到参数值：</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let name1 = Symbol.for(&apos;name1&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">let name2 = Symbol.for(&apos;name2&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log(Symbol.keyFor(name1));&nbsp;&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// &apos;name1&apos;</span></div><div><font face="微软雅黑" style="font-size: 14pt;"><span style="color: rgb(45, 79, 201);">console.log(Symbol.keyFor(name2));</span> <span style="color: rgb(168, 168, 168);">// &apos;name2&apos;</span></font></div><div><font face="微软雅黑" style="font-size: 14pt;"><br/></font></div></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><b>Object扩展</b></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#E30000" face="微软雅黑" style="font-size: 14pt;">Object.getOwnPropertySymbols(obj)&nbsp;</font></div><div><font face="微软雅黑" style="font-size: 14pt;">方法会返回当前对象的所有 Symbol 属性，返回数组</font></div><div><font color="#E30000" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#E30000" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#E30000" face="微软雅黑" style="font-size: 14pt;">Object.setPrototypeOf(obj1,obj2)</font></div><div><font face="微软雅黑" style="font-size: 14pt;">方法用来设置一个对象的 prototype 对象，与Object.getPrototypeOf 方法配套</font></div><div><font face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font face="微软雅黑" style="font-size: 14pt;">es5 实现原型链接</font></div><div><font face="微软雅黑" style="font-size: 14pt;"><font color="#2D4FC9">var obj1 = Object.create(obj2);</font>&nbsp;<font color="#A8A8A8">// 创建一个空对象,并把该对象的原型链接到obj2对象</font></font></div><div><font face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font face="微软雅黑" style="font-size: 14pt;">es6 实现原型链接</font></div><div><font face="微软雅黑" style="font-size: 14pt;"><font color="#2D4FC9">Object.setPrototypeOf(obj1,obj2);</font> <font color="#A8A8A8">// 把对象obj1的原型链接到obj2</font></font></div><div><font face="微软雅黑"><font color="#A8A8A8" style="font-size: 14pt;"><br/></font></font></div><div><font face="微软雅黑"><font color="#A8A8A8" style="font-size: 14pt;"><br/></font></font></div><div><font color="#E30000" face="微软雅黑" style="font-size: 14pt;">Object. getOwnPropertyDescriptors(obj)</font></div><div><font face="微软雅黑" style="font-size: 14pt;">获取指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">var obj2 = {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><span>&nbsp;&nbsp; &nbsp;</span>name: &apos;xm&apos;,</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><span>&nbsp;&nbsp; &nbsp;</span>age: 23</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">var attrObj1 = Object.getOwnPropertyDescriptor(obj2,&apos;name&apos;);</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// ES5获取一个属性的描述符</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">var attrObj2 = Object. getOwnPropertyDescriptors(obj2);</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// 获取所有自身属性的描述符</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log(attrObj1);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log(attrObj2);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#E30000" face="微软雅黑" style="font-size: 14pt;">Object.values(obj)</font></div><div><font color="#000000" face="微软雅黑" style="font-size: 14pt;">方法返回一个数组，成员是参数对象自身的所有可枚举属性的值（与Object.keys配套）</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">var obj = { foo: &apos;abc&apos;, baz: 123 };</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log(Object.values(obj));</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#E30000" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#E30000" face="微软雅黑" style="font-size: 14pt;">Object.entries(obj)</font></div><div><font face="微软雅黑" style="font-size: 14pt;">方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">const obj = { foo: &apos;bar&apos;, baz: 42 };</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">Object.entries(obj); // [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font face="微软雅黑" style="font-size: 14pt;">除了返回值不一样，该方法的行为与Object.values基本一致（不包括Symbol属性/值）</font></div><div><font color="#E30000" face="微软雅黑" style="font-size: 14pt;">Object.entries方法可以将对象转为真正的Map结构</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">const obj = { foo: &apos;bar&apos;, baz: 42 };</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">const map = new Map(Object.entries(obj));</font></div><div><font style="font-size: 14pt;"><font color="#2D4FC9" face="微软雅黑">console.log(map);</font> <font color="#A8A8A8" face="微软雅黑">// Map { foo: &quot;bar&quot;, baz: 42 }</font></font></div><div><font face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#E30000" face="微软雅黑" style="font-size: 14pt;">Object.assign(target,source)</font></div><div><font face="微软雅黑" style="font-size: 14pt;">方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">var obj1 = {a: 1, b: 2, c: {d: 4, e: 5}};</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">var obj2 = Object.assign({}, obj1);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log(obj1.c === obj2.c);</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// ture</font></div><div><font face="微软雅黑" style="font-size: 14pt;">Object.assign 方法是一种对象浅拷贝，如果对象属性是引用类型，只能是拷贝引用地址</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font face="微软雅黑" style="font-size: 14pt;">对象深拷贝</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">var obj1 = {a: 1, b: 2, c: {d: 4, e: 5}};</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">var obj2 = JSON.parse(JSON.stringify(obj1));</font></div><div><font style="font-size: 14pt;"><font color="#2D4FC9" face="微软雅黑">console.log(obj1.c === obj2.c);</font> <font color="#A8A8A8" face="微软雅黑">// false</font></font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#E30000" face="微软雅黑" style="font-size: 14pt;">Object.is(val1,val2)</font></div><div><font face="微软雅黑" style="font-size: 14pt;">方法用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</font></div><div><font color="#E30000" face="微软雅黑" style="font-size: 14pt;">不同之处只有两个：一是: +0不等于-0，二是: NaN等于自身。</font></div><div><font color="#E30000" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">+0 === -0</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">//true</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">NaN === NaN</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// false</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">{} === {}</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// false</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">Object.is({}, {});</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// false</font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font face="微软雅黑" style="color: rgb(227, 0, 0); font-size: 14pt;">Object.is(+0, -0)</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// false</font></div><div><font face="微软雅黑" style="color: rgb(227, 0, 0); font-size: 14pt;">Object.is(NaN, NaN)</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// true</font></div></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(227, 0, 0); font-weight: bold;">ES6 类与继承</span></div><div><br/></div><div><span style="font-size: 14pt;">ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。</span></div><div><span style="font-size: 14pt;">新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。</span></div><div><span style="font-size: 14pt;">无需考虑ES5中令人头疼的几个部分：构造函数、原型、继承...</span></div><div><br/></div><div><span style="font-size: 14pt;">用class定义一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。</span></div><div><br/></div><div><span style="font-size: 14pt;">class之间可以通过extends关键字实现继承，这比ES5通过修改原型链实现继承，要清晰和方便很多。</span></div><div><br/></div><div><span style="font-size: 14pt;">super关键字，它指向父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</span></div><div><br/></div><div><span style="font-size: 14pt;">ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造</span><span style="font-size: 14pt;">函数修改this。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑;">// es6类与继承</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">class Cat {</span></div><div><span style="font-family: 微软雅黑; color: rgb(54, 101, 238); font-size: 14pt;">&nbsp; &nbsp; mm = 78</span><span style="font-family: 微软雅黑; color: rgb(54, 101, 238); font-size: 14pt;">9;&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 原型上的属性</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;constructor(n,c){&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 构造器</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = n;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.color = c;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.trait = function () {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&apos;卖萌~&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;skill(){&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 原型上的方法</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(&apos;抓老鼠&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">class Dog extends Cat {&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 继承</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;constructor(n,c,f){</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(n,c);</span> <span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// 构造函数继承</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(54, 101, 238);"><font face="微软雅黑" style="font-size: 14pt;">&nbsp;this.food = f;</font></span></div><div><font face="微软雅黑" style="font-size: 14pt;"><span>&nbsp;&nbsp; &nbsp;</span><span>&nbsp;&nbsp; &nbsp;</span>// super.skill();//super当一个对象来使用时,只能访问方法(函数)</font></div><div><font face="微软雅黑" style="font-size: 14pt;"><span>&nbsp;&nbsp; &nbsp;</span><span>&nbsp;&nbsp; &nbsp;</span>// console.log(super.abc);//不能访问属性</font></div><div><font face="微软雅黑" style="font-size: 14pt;"><span>&nbsp;&nbsp; &nbsp;</span><span>&nbsp;&nbsp; &nbsp;</span>// console.log(this.abc);//123</font></div><div><font face="微软雅黑" style="font-size: 14pt;"><span>&nbsp;&nbsp; &nbsp;</span><span>&nbsp;&nbsp; &nbsp;</span>// this.skill();//&apos;抓老鼠&apos;</font></div><div><font face="微软雅黑" style="font-size: 14pt;"><span>&nbsp;&nbsp; &nbsp;</span><span>&nbsp;&nbsp; &nbsp;</span>// console.log(super);报错</font></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">&nbsp;&nbsp;&nbsp;&nbsp;};</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">}</span></div><div><br/></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">var dog1 = new Dog(&apos;大黄&apos;,&apos;黑色&apos;,&apos;shi&apos;);</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">dog1.trait();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">dog1.skill();</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">console.log( dog1.name );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">console.log( dog1.color );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( dog1.food );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">console.log( dog1.mm );</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(54, 101, 238);">console.log( dog1.constructor );&nbsp;</span><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(168, 168, 168);">// Dog</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></en-note>]]></content><created>20190824T054707Z</created><updated>20190826T151007Z</updated><note-attributes><author>陶舒健</author><source>desktop.win</source><source-application>yinxiang.win32</source-application></note-attributes></note></en-export>
