<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export2.dtd">
<en-export export-date="20190904T145942Z" application="Evernote/Windows" version="6.x">
<note><title>day24</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note><div><span style="font-size: 16pt; color: rgb(227, 0, 0); font-weight: bold;">Promise - “承诺”</span></div><div><br/></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal;">Promise 是ES6对异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理更强大。</span></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">Promise 简单说就是一个容器，里面保存着</span><span style="font-size: 14pt; color: rgb(51, 51, 51);">一个尚未完成且预计在未来完成的异步操作</span><span style="font-size: 14pt; color: rgb(51, 51, 51);">。</span></div><div><br/></div><div><span style="font-size: 14pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal;">Promise 是一个构造函数，用来创建一个</span><span style="font-size: 14pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal;">Promise对象。</span></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">Promise对象代表一个异步操作，有三种状态：</span></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">pending（进行中）</span></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">fulfilled（成功）</span></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">rejected（失败）</span></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">Promise 对象的状态改变有两种：</span></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">从 pending 变为 fulfilled</span></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">从 pending 变为 rejected</span></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">一旦状态改变，就不会再变，任何时候都可以得到这个结果。</span></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">有了Promise对象，就可以</span><span style="font-size: 14pt; color: rgb(227, 0, 0);">将异步操作以同步操作的流程表达出来</span><span style="font-size: 14pt; color: rgb(51, 51, 51);">，避免了层层嵌套的回调函数。</span></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">var p = new Promise(function(resolve, reject) {</span></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">&nbsp;&nbsp;</span><span style="font-size: 14pt; color: rgb(168, 168, 168);">// do something ...</span></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">&nbsp;&nbsp;if (</span><span style="font-size: 14pt; color: rgb(168, 168, 168);">/* 异步操作成功 */</span><span style="font-size: 14pt; color: rgb(45, 79, 201);">){</span></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;resolve(value);</span></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">&nbsp;&nbsp;} else {</span></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">&nbsp;&nbsp;&nbsp;&nbsp;reject(error);</span></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">&nbsp;&nbsp;}</span></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">});</span></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</span></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">resolve 和 reject&nbsp;</span><span style="font-size: 14pt; color: rgb(51, 51, 51);">是两个函数，由 JavaScript 引擎提供，不用自己部署。</span></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">resolve 函数的作用是，将Promise对象的状态从“进行中”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</span></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">reject 函数的作用是，将Promise对象的状态从“进行中”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</span></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">p.</span><span style="font-size: 14pt; color: rgb(227, 0, 0);">then</span><span style="font-size: 14pt; color: rgb(45, 79, 201);">(function(value) {</span></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">&nbsp;&nbsp;</span><span style="font-size: 14pt; color: rgb(168, 168, 168);">// success</span></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">}, function(error) {</span></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">&nbsp;&nbsp;</span><span style="font-size: 14pt; color: rgb(168, 168, 168);">// failure&nbsp; 可选</span></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">});</span></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">Promise实例的</span><span style="font-size: 14pt;"><font style="color: rgb(227, 0, 0);">then</font></span><span style="font-size: 14pt; color: rgb(51, 51, 51);">方法：</span></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">第一个参数是resolved状态的回调函数</span></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">第二个参数（可选）是rejected状态的回调函数</span></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">方法返回的是一个新的Promise实例</span></div><div><br/></div><div><font style="font-size: 14pt;"><span style="color: rgb(51, 51, 51);">Promise实例的</span><span style="color: rgb(227, 0, 0);">catch</span><span style="color: rgb(51, 51, 51);">方法：用于指定发生错误时的回调函数，可以捕获then里面的错误。</span></font></div><div><font style="font-size: 14pt;"><span style="color: rgb(51, 51, 51);"><br/></span></font></div><div><font style="font-size: 14pt; color: rgb(45, 79, 201);">throw new Error(&apos;出错啦&apos;);</font></div><div><font style="font-size: 14pt; color: rgb(45, 79, 201);"><br/></font></div><div style="margin: 10px auto; padding: 0px; list-style-type: none; list-style-image: none; text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-align: start; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px;"><span style="text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px; font-size: 14pt; font-variant-caps: normal;"><font style="color: rgb(227, 0, 0);">Promise.all&nbsp;</font></span><span style="text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(68, 68, 68); font-variant-caps: normal;">可以将多个Promise实例包装成一个新的Promise实例。</span></div><div style="margin: 10px auto; padding: 0px; list-style-type: none; list-style-image: none; text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-align: start; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px;"><span style="text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(68, 68, 68); font-variant-caps: normal;">1.它接受一个数组作为参数。</span></div><div style="margin: 10px auto; padding: 0px; list-style-type: none; list-style-image: none; text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-align: start; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px;"><span style="text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(68, 68, 68); font-variant-caps: normal;">2.数组可以是Promise对象，也可以是其它值，只有Promise会等待状态改变。</span></div><div style="margin: 10px auto; padding: 0px; list-style-type: none; list-style-image: none; text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-align: start; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px;"><span style="text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(68, 68, 68); font-variant-caps: normal;">3.当所有的子Promise都完成，该Promise完成，返回值是全部值的数组。</span></div><div style="margin: 10px auto; padding: 0px; list-style-type: none; list-style-image: none; text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-align: start; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px;"><span style="text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(68, 68, 68); font-variant-caps: normal;">4.如果有任何一个失败，该Promise失败，返回值是第一个失败的子Promise的结果。</span></div><div style="margin: 10px auto; padding: 0px; list-style-type: none; list-style-image: none; text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-align: start; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px;"><span style="text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(68, 68, 68);">Promise.all([p1,p2,p3]).then(function (arr){</span></div><div style="margin: 10px auto; padding: 0px; list-style-type: none; list-style-image: none; text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-align: start; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px;"><span style="text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(68, 68, 68);">&nbsp; &nbsp; console.log(arr);</span></div><div style="margin: 10px auto; padding: 0px; list-style-type: none; list-style-image: none; text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-align: start; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px;"><span style="text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(68, 68, 68);">},function (error){</span></div><div style="margin: 10px auto; padding: 0px; list-style-type: none; list-style-image: none; text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-align: start; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px;"><span style="text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(68, 68, 68);">&nbsp; &nbsp; console.log(error);</span></div><div style="margin: 10px auto; padding: 0px; list-style-type: none; list-style-image: none; text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-align: start; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px;"><span style="text-indent: 0px; caret-color: rgb(68, 68, 68); letter-spacing: normal; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(68, 68, 68);">});</span></div><div style="margin: 10px auto; padding: 0px; list-style-type: none; list-style-image: none; text-indent: 0px; caret-color: rgb(68, 68, 68); font-size: 14px; letter-spacing: normal; text-align: start; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-tap-highlight-color: rgba(26, 26, 26, 0.3); text-size-adjust: none; -webkit-text-stroke-width: 0px;"><br/></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">1.Promise 改造 函数嵌套</span></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(51, 51, 51);">2.Promise 改造 ajax嵌套依赖</span></div><div><br/></div><div><br/></div><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">了解 fetch 与&nbsp;</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">axios</span></div><div><br/></div><div><span style="font-size: 14pt; box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal;">fetch：</span><span style="font-size: 14pt; color: rgb(47, 47, 47);">号称是AJAX的替代品，是基于promise设计的。</span></div><div><span style="font-size: 14pt; color: rgb(47, 47, 47);">fetch不是ajax的进一步封装，而是原生js，代码结构比起ajax简单多了。</span></div><div><br/></div><div><span style="font-size: 14pt; box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(47, 47, 47); font-variant-caps: normal; font-variant-ligatures: normal;">axios：</span><span style="font-size: 14pt; color: rgb(47, 47, 47);">是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</span></div><div><span style="font-size: 14pt; color: rgb(47, 47, 47);">vue官方推荐的HTTP请求库。</span></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt; font-weight: bold;">Generator</span> <span style="font-size: 14pt; font-weight: bold;">遍历器生成函数</span></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt;">Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</span></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt;">语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</span></div><div><span style="font-size: 14pt;"><span style="font-size: 14pt;">形式上，Generator 函数是一个普通函数，但是有两个特征：</span></span></div><div><span style="font-size: 14pt; color: rgb(227, 0, 0);">一是，function关键字与函数名之间有一个星号 *；二是，函数体内部使用yield表达式，定义不同</span><span style="font-size: 14pt; color: rgb(227, 0, 0);">的内部状态（yield 即“产出”）。</span></div><div><font style="font-size: 14pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// Generator 遍历器生成函数</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">function</font><font color="#DE5700" face="微软雅黑" style="font-size: 14pt;">*</font> <font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">myGenerator(){</font></div><div><font face="微软雅黑" style="font-size: 14pt;"><span style="color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;</span><font color="#DE5700">yield</font></font> <font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&apos;hello&apos;;</font></div><div><font face="微软雅黑" style="font-size: 14pt;"><span style="color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;</span><font color="#DE5700">yield</font></font> <font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&apos;world&apos;;</font></div><div><font face="微软雅黑" style="font-size: 14pt;"><span style="color: rgb(45, 79, 201);">&nbsp; &nbsp;</span> <font color="#DE5700">yield</font></font><font color="#DE5700">&nbsp;</font><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&apos;result&apos;;</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">var iterator = myGenerator();</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log( iterator );</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// 遍历器对象（Iterator Object）</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log( iterator.next() );</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// {value: &quot;hello&quot;, done: false}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log( iterator.next() );</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// {value: &quot;world&quot;, done: false}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log( iterator.next() );</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// {value: &quot;result&quot;, done: false}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log( iterator.next() );</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// {value: undefined, done: true}</font></div></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;">执行 Generator 函数会返回一个遍历器对象，是一个遍历器对象生成函数。</span></div><div><span style="font-size: 14pt;">每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。</span></div><div><span style="font-size: 14pt;">value表示当前的内部状态的值，是yield后面那个表达式的值；done是一个布尔值，表示是否遍历结束。</span></div><div><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(227, 0, 0);">Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，其实是提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</span></span></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;">for...of循环，扩展运算符（...）、解构赋值和Array.from等方法，内部调用的都是遍历器接口。</span></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;">任意一个对象的Symbol.iterator方法</span><span style="font-size: 14pt;">（数组，字符串， Set，Map，</span><span style="font-size: 14pt;">元素集合，arguments</span><span style="font-size: 14pt;">）</span><span style="font-size: 14pt;">，等于该对象的遍历器生成函数（</span> <span style="font-size: 18.6667px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">Generator</span><span style="font-size: 14pt;">），调用该函数会返回该对象的一个遍历器对象。</span></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;">原生js对象不具备 Iterator 接口，无法使用上述接口，将 Generator 函数加到对象的</span><span style="font-size: 14pt;">Symbol.iterator属性上面即可使用。</span></div><div><font style="font-size: 14pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">function</font><font color="#DE5700" face="微软雅黑" style="font-size: 14pt;">*</font> <font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">objGenerator() {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;let keys = Object.keys(this);</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">//&nbsp;[&quot;name&quot;, &quot;sex&quot;, &quot;aeg&quot;]</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;for (let key of keys) {</font></div><div><font face="微软雅黑" style="font-size: 14pt;"><span style="color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;</span><span style="color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;</span><font color="#DE5700">yield</font></font> <font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">[key, this[key]];&nbsp;</font><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// [key,value]</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">let xmObj = { name: &apos;xiaoming&apos;, sex: &apos;男&apos;, aeg: 23 };</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// 将 Generator 函数加到对象的Symbol.iterator属性上面</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">xmObj[Symbol.iterator] = objGenerator;</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">for (let [key, value] of xmObj) {</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// 可以使用for/of遍历</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;console.log(`${key}: ${value}`);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// name: xiaoming</font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// sex: 男</font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// aeg: 23</font></div></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt; font-weight: bold;">async和await</span></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt;">async 函数是什么？一句话，它就是 Generator 函数的语法糖。</span></div><div><span style="font-size: 14pt;">async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</span></div><div><span style="font-size: 14pt;">async和await，比起星号和yield，语义更清楚了。</span></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(227, 0, 0);">async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</span></span></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt;">async函数返回一个 Promise 对象，可以使用then方法添加回调函数。</span></div><div><span style="font-size: 14pt;">async函数内部return语句返回的值，会成为then方法回调函数的参数。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">async function fn() {</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;return &apos;hello world&apos;;</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">}</span></div><div><span style="font-size: 14pt; font-family: 微软雅黑; color: rgb(45, 79, 201);">fn().then(v =&gt; console</span><font face="微软雅黑" style="font-size: 14pt;"><span style="color: rgb(45, 79, 201);">.log(v));&nbsp;</span><font color="#A8A8A8">// &quot;hello world&quot;</font></font></div><div><font face="微软雅黑" style="font-size: 14pt;"><span style="color: rgb(45, 79, 201);"><font>console.log(&apos;我先执行&apos;);&nbsp;</font></span><font color="#A8A8A8">// &quot;我先执行&quot;</font></font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">console.log( fn() );</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// Promise {&lt;resolved&gt;: &quot;hello world&quot;}</font></div></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;">async 函数有多种使用形式。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// 函数声明</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">async function foo() {}</font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// 函数表达式</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">let foo = async function () {};</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// 对象的方法</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">let obj = { async foo() {} };</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">obj.foo().then(...)</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// Class 的方法</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">class Storage {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;constructor() {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this.cachePromise = caches.open(&apos;avatars&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;async getAvatar(name) {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;const cache = await this.cachePromise;</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return cache.match(`/avatars/${name}.jpg`);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">const storage = new Storage();</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">storage.getAvatar(&apos;jake&apos;).then(…);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// 箭头函数</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">let foo = async () =&gt; {};</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;"><br/></font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// 立即执行函数</font></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">(async function (){</span></div><div><span style="font-size: 14pt;"><font color="#2D4FC9">&nbsp; &nbsp;</font> <font color="#A8A8A8">// ...</font></span></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);">})();</span></div></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt;">async函数内部抛出错误，导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch</span><span style="font-size: 14pt;">方法回调函数接收到。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">async function fn() {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;throw new Error(&apos;出错了&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">fn().then(</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;v =&gt; console.log(v),</font></div><div><font face="微软雅黑"><span style="color: rgb(45, 79, 201); font-size: 14pt;">&nbsp;&nbsp; &nbsp;e =&gt; console.log(e)</span> <font color="#A8A8A8" style="font-size: 14pt;">// catch&nbsp;</font></font><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">Error: 出错了</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">)</font></div></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt;">await 命令</span></div><div><span style="font-size: 14pt;">正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对</span><span style="font-size: 14pt;">象，就直接返回对应的值。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">async function fn() {</font></div><div><font face="微软雅黑"><span style="color: rgb(45, 79, 201); font-size: 14pt;">&nbsp;&nbsp; &nbsp;</span><font color="#2D4FC9" style="font-size: 14pt;">return await 123;</font></font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;// 等同于</font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;// return 123;</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">fn().then( v =&gt; console.log(v) );</font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// 123</font></div></div><div><span style="font-size: 14pt;">上面代码中，await命令的参数是数值123，这时等同于return 123。</span></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(227, 0, 0);">注意，await一定要运行在async 函数内！</span></span></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;">当</span><span style="font-size: 14pt;">async函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内</span><span style="font-size: 14pt;">后面的语句。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">(async function (){</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;var res1 = await new Promise(function (resolve,reject){</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;setTimeout(function (){</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;console.log(&apos;异步任务1&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;resolve(&apos;成功1&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;},1000);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;});</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;var res2 = await new Promise(function (resolve,reject){</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;setTimeout(function (){</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;console.log(&apos;异步任务2&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;resolve(&apos;成功2&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;},1000);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;});</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;console.log(res1,res2);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;console.log(&apos;同步任务3&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;console.log(&apos;同步任务4&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">})();</font></div></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal;">&nbsp;</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal;">await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。</span></font></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;">await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接</span><span style="font-size: 14pt;">收到。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">async function fn() {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;await Promise.reject(&apos;出错了&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">fn().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))</font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// 出错了</font></div></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;">任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">async function fn() {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;await Promise.reject(&apos;出错了&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;await Promise.resolve(&apos;hello world&apos;);</font> <font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// 不会执行</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">fn().then(</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;v =&gt; console.log(v),</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;err =&gt; console.log(err)</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">);</font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// &apos;出错了&apos;</font></div></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;">await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch</span><span style="font-size: 14pt;">代码块中。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">async function f() {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;try {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;await Promise.reject(&apos;出错了&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;} catch(e) {</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;console.log(e);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;return await Promise.resolve(&apos;hello world&apos;);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">}</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">f().then(v =&gt; console.log(v));</font></div><div><font color="#A8A8A8" face="微软雅黑" style="font-size: 14pt;">// hello world</font></div></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;">async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作</span><span style="font-size: 14pt;">执行完，才会执行then方法指定的回调函数。</span></div><div><font style="font-size: 14pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">(async function (){</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;var res1 = await promiseAjax({</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;type: &apos;get&apos;,</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url: &apos;datas.php&apos;,</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;data: &apos;userid=abc1001&apos;</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;});</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;var res2 = await promiseAjax({</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;type: &apos;get&apos;,</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url: &apos;datas.php&apos;,</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;data: &apos;userid=abc1002&apos;</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;});</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;var res3 = await promiseAjax({</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;type: &apos;get&apos;,</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url: &apos;datas.php&apos;,</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;data: &apos;userid=abc1003&apos;</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;});</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;res1 = JSON.parse(res1);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;res2 = JSON.parse(res2);</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;res3 = JSON.parse(res3);</font></div><div><font face="微软雅黑" style="font-size: 14pt;"><span style="color: rgb(45, 79, 201);">&nbsp;&nbsp; &nbsp;</span><font color="#A8A8A8">// con.innerHTML = `姓名：${res1.name}，身份证：${res2.idcode}，地址：${res3.address}`;</font></font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;return `姓名：${res1.name}，身份证：${res2.idcode}，地址：${res3.address}`;</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">})().then(val=&gt;{</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">&nbsp;&nbsp; &nbsp;con.innerHTML = val;</font></div><div><font color="#2D4FC9" face="微软雅黑" style="font-size: 14pt;">});</font></div></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt;"><br/></span></div></en-note>]]></content><created>20190830T081259Z</created><updated>20190904T141351Z</updated><note-attributes><author>陶舒健</author><source>desktop.win</source><source-url>http://es6.ruanyifeng.com/#docs/generator</source-url><source-application>yinxiang.win32</source-application></note-attributes></note></en-export>
